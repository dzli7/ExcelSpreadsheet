CS130 Project 2 - Design Document
=================================

Please answer all questions in this design document.  Note that the final
feedback section is optional, and you are not required to answer it if you
don't want to.

Unanswered or incompletely answered questions, or answers that don't actually
match the code/repository, will result in deductions.

Answers don't have to be deeply detailed!  We are mainly looking for an
overview or summary description of how your project works, and your team's
experiences working on this project.

Logistics (7 pts)
-----------------

L1.  [2pts] Enumerate all teammates here.

    Daniel Li
    Hernan Caceres
    Carl Cheng

L2.  [2pts] What did each teammate focus on during this project?

    Daniel Li: rename sheet, lark parsing for formula, tests
    Hernan Caceres: major functions, tests
    Carl Cheng: functions, tests, profiler

L3.  [3pts] Approximately how many hours did each teammate spend on the project?

    Daniel Li: 16 hrs
    Hernan Caceres: 12 hrs
    Carl Cheng: 9 hrs

Spreadsheet Engine Design (10 pts)
----------------------------------

D1.  [3pts] Briefly describe how your workbook-loading code operates.  Does
     it do anything sophisticated to optimize the performance of loading a
     workbook, such as deferring cell-value update calculations, or analyzing
     the graph of cell dependencies?

     The workbook loading code takes a json file, and breaks down the
     various nested key-value pairs in the json, so that each cell
     in the json is iterated through, and its contents are added to 
     the appropriate sheet name and location pair via the set_cell_contents
     function. Within this call to set_cell_contents, the graph of cell
     dependencies is analyzed. Moving forward, we can look into the 
     possibility of deffering cell-value update calculations, as our
     performance analysis tests revealed our current implementation is
     not efficient. 

D2.  [3pts] Sheet-level operations like copying a sheet, deleting a sheet,
     renaming a sheet, or even creating a new sheet, can cause cell values
     to be updated.  How does your workbook identify such cells and ensure
     that they are updated properly?

      For sheet level operations, we first store a list of cells that have bad
      references (self.bad_ref_cells). If for any cell in the list of bad references 
      the new sheet name is equal to the parent sheet name of the bad reference, we 
      look to update that cell. This function is called each of the sheet level operations.
      It is important to know that the only cells whose values will be updated
      are cells whos values were previously Bad References.

D3.  [4pts] When renaming a sheet, cells with formulas that explicitly
     reference the renamed sheet must be updated with the new sheet name.
     Give an overview of how your implementation updates these formulas.

     We update the formulas that explicitly reference the rename sheet by 
     putting the contents of the cell, which should be a formula, into a 
     lark transformer. In the transformer, we return everything as a string
     as it is, unless it is a cell. If it is a cell and the sheet of the cell
     (if it exists) is equal to the new sheet name, we replace it. At the 
     end, we add an '=' for recreate the formula


Spreadsheet Engine Code Review (17 pts)
---------------------------------------

R1.  [2pts] What part of your spreadsheet code-base did your team select to
     review?  Why did you select this portion of your code to review?

     We decided the review the section of our code where we test for a circular
     dependency and if we don't, how we build the dependency graph to update
     the values of the tree rooted at the cell we are setting the contents of.
     We decided to choose this section of the code because it was one of the tests
     that failed a specific acceptance tests of project 1. It was briefly looked at
     when initially attempting to debug all of the errors but was flagged for further
     review after an initial trivial attempt didn't fix the error.

R2.  [2pts] Approximately how much code did your team review?  How much time did
     the meeting take?

     We reviewed ~150 lines of code. The meeting took ~40 minutes 

R3.  [6pts] Include the list of action-items that were generated by the
     code-review here.

     Need to comment code, difficult to tell what is happening
     Identify location of infinite loop
     Brainstorm solutions on ipad -> pseudocode best ideas
     Run test cases on ipad with proposed solutions
        if solution works -> implement
        if none work -> rebrainstorm

R4.  [3pts] Have you been able to address the action items identified?  If not,
     what is your plan and timeframe to do so?

     Yes, we have been able to address the action items. We essentially followed
     the plan of action items listed. We were able to pinpoint the location in 
     the code where the loop was occuring. After an iPad session, we were able
     to create a solution that solved the problem.

R5.  [4pts] Reflect on whether the code review helped with knowledge-sharing in
     the team.  Do teammates feel more confident maintaining the code that was
     reviewed, and/or extending the code in the future?

     We do believe that the code review helped with the knowledge sharing in the
     team. Because the implementation of the circular dependency was done mainly 
     by one teammate, the code review showed the others on how it was done. Teammates
     definitely feel more confident in maintaining/extending the code.


Performance Analysis (16 pts)
-----------------------------

In this project you must measure and analyze the performance of two central
areas of your spreadsheet engine.  Using pair programming, construct some
performance tests to exercise these aspects of your engine, and use a profiler
to identify where your program is spending the bulk of its time.

A1.  [4pts] Briefly enumerate the performance tests you created to exercise
     your implementation, along with the teammates that collaborated to
     implement each of them.

     1. Large cycle (cycle of n=1000) stress test
          Carl, Daniel
     2. Small cycle (n=1000 cycles of 2) stress test
          Carl, Daniel
     3. Rename stress test
          Carl, Hernan
     4. Long chain (cell chain of n=1000) stress test
          Carl, Daniel
     5. Wide chain (one cell referenced n=1000 times) stress test
          Carl, Daniel
     6. Recursive fibonacci stress test
          Carl, Daniel


A2.  [2pts] What profiler did you choose to run your performance tests with?
     Why?  Give an example of how to invoke one of your tests with the profiler.

     We chose to use pyinstrument due to its clear documentation and ease of
     use. Pyinstrument is a sampling profiler which means we can easily decide
     when the profiler starts sampling and when it stops sampling using
     profiler.start() and profiler.stop(). For example, if we wanted to test
     the circular dependency code with a large cycle (n >= 1000), we could
     initialize a broken cycle of length 999 (A2: =A1, A3: =A2, ...,
     A1000: =A999), then right before we complete the cycle (A1: =A1000) we
     start the profiler and stop it right after. Thus, we would only be
     profiling the part of the code that handles circular dependencies.

A3.  [6pts] What are ~3 of the most significant hot-spots you identified in your
     performance testing?  Did you expect these hot-spots, or were they
     surprising to you?

     3 of the most significant hot-spots we identified in performance testing
     are long chains, small cycles, and recursive formulas such as fibonacci.
     Fibonacci and long chains are significant hot-spots for the same reason;
     when we make a set_cell_contents call that requires updating the contents
     of many other parent cells, our recursive calls branch into two recursive
     calls, which makes recursive formulas and long chains of input size n have
     a runtime of O(2^n), which is very inefficient. On the other hand, we were
     able to successfully improve small cycles due to a bug in our circular
     dependency algorithm.


A4.  [4pts] Reflect on the experience of pair-programming as you constructed
     these tests.  What went well with it?  What would you like to try to do
     better in the future?

     The paired programming helped with brainstorming tests and deciding
     what parts of code we wanted to test. In the future, we could try to
     have the stress test additionally determine runtime complexity since
     we had to increment the input size n in order to confirm the runtime
     complexity we expected.


Section F:  CS130 Project 2 Feedback [OPTIONAL]
-----------------------------------------------

These questions are OPTIONAL, and you do not need to answer them.  Your grade
will not be affected by answering or not answering them.  Also, your grade will
not be affected by negative feedback - we want to know what went poorly so that
we can improve future versions of the course.

F1.  What parts of the assignment did you find highly enjoyable?  Conversely,
     what parts of the assignment did you find unenjoyable?


F2.  What parts of the assignment helped you learn more about software
     engineering best-practices, or other useful development skills?
     What parts were not helpful in learning these skills?


F3.  Were there any parts of the assignment that seemed _unnecessarily_ tedious?
     (Some parts of software development are always tedious, of course.)


F4.  Do you have any feedback and/or constructive criticism about how this
     project can be made better in future iterations of CS130?